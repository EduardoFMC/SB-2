;macro para ler uma string
%macro read_str_macro 2
mov eax, 3
mov ebx, 0
mov ecx, %1 
mov edx, %2 
int 80h
%endmacro

;macro para printar uma string
%macro print_str_macro 2
mov eax, 4
mov ebx, 1 
mov ecx, %1
mov edx, %2
int 80h
%endmacro

;;;;; INPUT. INPUT INT
;; STR -> INT
input_int:
	enter	4,0

	push	EBX
	push	ECX
	push	EDX

	read_str_macro [ebp+8], max_int

	mov		ECX,EAX ;edx vai guardar o tamanho da string
	mov		EDI,[EBP+8] ;edi guarda o ponteiro para a string
	sub		ECX,1

	mov 	EBX,10 ;multiplicador

	push 	EDX
	mov 	DL,[EDI] ;valor do primeiro caractere da string
	cmp 	EDX,'-'
	jne 	positivo

	pop 	EDX
	inc		EDI ;pula -
	sub 	ECX,1 ;loop pula 1 posi√ß√£o, j√° que em 0 tem -
	mov 	DWORD [EBP-4],-1 ;sinaliza que √© negativo
	jmp 	continua

positivo:
	pop 	EDX
	mov 	DWORD [EBP-4],1 ;sinaliza que √© positivo

continua:
	push 	EAX
	and 	EAX,0 ;soma come√ßa zerada

passa:
	push	EDX ;edx √© alterado com mul, ent√£o precisa salvar o tamanho da string
	imul 	EBX
	add 	AL,[EDI]
	sub 	AL,0x30
	pop 	EDX
	inc		EDI
	loop 	passa
	imul 	DWORD [EBP-4]

	mov 	[num_int],eax

	pop		EAX
	pop 	EDX
	pop 	ECX
	pop 	EBX

    mov   	[size_of_s_input_output_int], eax
    push 	eax

    push	DWORD [size_of_s_input_output_int] ; empilha o tamanho em INT
	push	size_of_s_input_output_str ; empilha onde vai guardar o tamanho em STR
	call	get_pos_int_str

    print_str_macro     msg_read_bytes, size_read_bytes
    print_str_macro     size_of_s_input_output_str, [size_of_s_input_output_int]
    print_str_macro     msg_bytes, size_bytes_msg
    print_str_macro     newl, 1

    pop eax

	leave
	ret		4

get_pos_int_str:
	enter	0,0

	push	EBX
	push	ECX
	push	EDX

	mov		EDI,[EBP+8] ;edi = string vazia
	mov		EAX,[EBP+12] ;eax = n√∫mero
	mov		EBX,10 ;ebx = divisor

	and		ECX,0 ;ecx = iterador

passa_int_str:
	and		edx,0
	idiv	ebx

	add		edx,0x30
	push 	EDX

	inc		ecx ;incrementa ecx para depois desempilhar
	cmp 	eax,0
	jne		passa_int_str

	and		ebx,0

digitos_int_str:
	pop		edx
	mov 	[edi],edx
	inc		edi

	inc		ebx
	cmp 	ebx,ecx
	jne 	digitos_int_str

	pop 	EDX
	pop 	ECX
	pop 	EBX

	leave
	ret		8

;;;; OUTPUT. OUTPUT INT
;; Pode ser utilizado como int -> str
output_int:
	enter	4,0

	push	EBX
	push	ECX
	push	EDX

	mov		EDI,[EBP+8] ;edi = string vazia
	mov		EAX,[EBP+12] ;eax = n√∫mero
	mov		EBX,10 ;ebx = divisor
	mov 	[EBP-4],EAX ;EBP-4 guarda o n√∫mero original

	and		ECX,0 ;ecx = iterador
	cmp		[EBP-4],ECX
	jl		negativo
	jmp		passa

negativo:
	;inc 	ecx
	;mov 	edx,"-"
	;push 	edx
	mov 	edx,-1
	imul 	edx

passa:
	and		edx,0
	idiv	ebx

	add		edx,0x30
	push 	EDX

	inc		ecx ;incrementa ecx para depois desempilhar
	cmp 	eax,0
	jne		passa

	and		ebx,0

	cmp		[EBP-4],EBX
	jl 		negativo_digito
	jmp		digitos

negativo_digito:
	inc 	ecx
	mov 	edx,"-"
	push 	edx

digitos:
	pop		edx
	mov 	[edi],edx
	inc		edi

	inc		ebx
	cmp 	ebx,ecx
	jne 	digitos

   	mov   	[size_of_s_input_output_int], ECX
    push 	ECX

	mov		EAX,4
	mov 	EBX,1
	mov		EDX,ECX
	mov 	ECX,[EBP+8]
	int 	80h

    push	DWORD [size_of_s_input_output_int] ; empilha o tamanho em INT
	push	size_of_s_input_output_str ; empilha onde vai guardar o tamanho em STR
	call	get_pos_int_str

	print_str_macro     newl, 1

    print_str_macro     msg_print_bytes, size_print_bytes
    print_str_macro     size_of_s_input_output_str, [size_of_s_input_output_int]
    print_str_macro     msg_bytes, size_bytes_msg
    print_str_macro     newl, 1

    pop 	EAX
	pop 	EDX
	pop 	ECX
	pop 	EBX

	leave
	ret		8

get_pos_int_str:
	enter	0,0

	push	EBX
	push	ECX
	push	EDX

	mov		EDI,[EBP+8] ;edi = string vazia
	mov		EAX,[EBP+12] ;eax = n√∫mero
	mov		EBX,10 ;ebx = divisor

	and		ECX,0 ;ecx = iterador

passa_int_str:
	and		edx,0
	idiv	ebx

	add		edx,0x30
	push 	EDX

	inc		ecx ;incrementa ecx para depois desempilhar
	cmp 	eax,0
	jne		passa_int_str

	and		ebx,0

digitos_int_str:
	pop		edx
	mov 	[edi],edx
	inc		edi

	inc		ebx
	cmp 	ebx,ecx
	jne 	digitos_int_str

	pop 	EDX
	pop 	ECX
	pop 	EBX

	leave
	ret		8

;;; INPUT_C. INPUT C
INPUT_C:

    enter   0,0

    push    ebx
    push    ecx
    push    edx

    read_str_macro      [ebp+8], 1

    print_str_macro     msg_read_bytes, size_read_bytes
    print_str_macro     n_1, 1
    print_str_macro     msg_bytes, size_bytes_msg
    print_str_macro     newl, 1

    pop    ebx
    pop    ecx
    pop    edx

    mov     eax, 1
    leave
    ret     4

;;;; OUTPUT_C, OUTPUT CHAR
OUTPUT_C:
    enter   0,0

    push    ebx
    push    ecx
    push    edx

    print_str_macro     [ebp+8], 1
    print_str_macro     newl, 1

    ; Foram imprimidos 1 bytes
    print_str_macro     msg_print_bytes, size_print_bytes
    print_str_macro     n_1, 1
    print_str_macro     msg_bytes, size_bytes_msg
    print_str_macro     newl, 1

    pop    ebx
    pop    ecx
    pop    edx

    mov     eax, 1
    leave
    ret     4

;;;  INPUT_S LABEL, x. Input string em LABEL, com ttamanho maximo x, e escreva o tamanho em byte
;; que pode ir at√© x
INPUT_S:

    enter    0,0

    push    ebx
    push    ecx
    push    edx

    read_str_macro [ebp+8], [ebp+12]
    
	mov		ebx, [ebp+16]
	mov		[ebx], eax	; tamnho real da string
    mov     [size_of_s_input_output_int], eax

    push	DWORD [size_of_s_input_output_int] ; empilha o tamanho em INT
	push	size_of_s_input_output_str ; empilha onde vai guardar o tamanho em STR
	call	input_s_str_to_int

    print_str_macro     msg_read_bytes, size_read_bytes
    print_str_macro     size_of_s_input_output_str, [size_of_s_input_output_int]
    print_str_macro     msg_bytes, size_bytes_msg
    print_str_macro     newl, 1

    pop    ebx
    pop    ecx
    pop    edx

    mov    eax, [size_of_s_input_output_int]

    leave
    ret     12

;; OUTPUT STRING. Ouput string e bytes escritos

OUTPUT_S:

    enter    0,0

    push    ebx
    push    ecx
    push    edx

	mov 	ebx, DWORD [ebp+12]
    mov     eax, [ebx]
    mov     [size_of_s_input_output_int], eax
    
    print_str_macro  [ebp+8], [size_of_s_input_output_int]

    push	DWORD [size_of_s_input_output_int] ; empilha o tamanho em INT
	push	size_of_s_input_output_str ; empilha onde vai guardar o tamanho em STR
	call	input_s_str_to_int

    print_str_macro     newl, 1

    ; Foram imprimidos x bytes
    print_str_macro     msg_print_bytes, size_print_bytes
    print_str_macro     size_of_s_input_output_str, [size_of_s_input_output_int]
    print_str_macro     msg_bytes, size_bytes_msg
    print_str_macro     newl, 1

    pop    ebx
    pop    ecx
    pop    edx

    mov    eax, [size_of_s_input_output_int]

    leave
    ret     8

;;;;; OUTPUT INT (INT->STR). Esse √© um especial do INPUT_S e output_S

input_s_str_to_int:
	enter	4,0

	push	EBX
	push	ECX
	push	EDX

	mov		EDI,[EBP+8] ;edi = string vazia
	mov		EAX,[EBP+12] ;eax = n√∫mero
	mov		EBX,10 ;ebx = divisor
	mov 	[EBP-4],EAX ;EBP-4 guarda o n√∫mero original

	and		ECX,0 ;ecx = iterador
	cmp		[EBP-4],ECX
	jl		ehneg
	jmp		continue

ehneg:

	mov 	edx,-1
	imul 	edx

continue:
	and		edx,0
	idiv	ebx

	add		edx,0x30
	push 	EDX

	inc		ecx ;incrementa ecx para depois desempilhar
	cmp 	eax,0
	jne		continue

	and		ebx,0

	cmp		[EBP-4],EBX
	jl 		neg_digit
	jmp		all_digits

neg_digit:
	inc 	ecx
	mov 	edx,"-"
	push 	edx

all_digits:
	pop		edx
	mov 	[edi],edx
	inc		edi

	inc		ebx
	cmp 	ebx,ecx
	jne 	all_digits

	pop 	EDX
	pop 	ECX
	pop 	EBX

	leave
	ret		8


%define max_int 12

section .data

msg_read_bytes       db     'Foram Lidos '
size_read_bytes      EQU    $-msg_read_bytes 

msg_print_bytes      db     'Foram Escritos '
size_print_bytes     EQU    $-msg_print_bytes

msg_bytes            db     ' Bytes'
size_bytes_msg       EQU    $-msg_bytes

newl                 dd     0Ah
n_1                  dd     '1'

DOIS	 dd 2
LETRA	 db "A"

section .bss

size_of_s_input_output_int     resd 10 ; var auxiliar, para sabermos quantos bytes imprimir. INT
size_of_s_input_output_str     resb 10; tamanho em bytes, sÛ que em str, string vazia pra receber o valor. STR

string_int 	resb 	max_int ; aux para com 'x'
num_int 	resd 1 ; aux com x

string_int 			resb 	max_int
num_int 	resd 1
OLD_DATA	 resd 3
NEW_DATA	 resd 1
TMP_DATA	 resd 1
CHAR	 resd 1
STRING	 resd 5

section.text
global _start

push string_int
call input_int
mov EAX, [num_int]
mov [OLD_DATA], EAX
mov EAX, [OLD_DATA]
L1: mov ECX, [DIV]
cdq
idiv ECX
mov [NEW_DATA], EAX
mov ECX, [DOIS]
imul ECX
mov [TMP_DATA], EAX
mov EAX, [OLD_DATA+2]
sub EAX, [TMP_DATA]
push dword [TMP_DATA]
call output_int
mov EBX, [NEW_DATA]
mov [OLD_DATA], EBX
mov EAX, [OLD_DATA]
CMP EAX, 0
JG L1
mov EAX, 1
mov EBX, 0
int 80h
